# Technical Architecture - Suiviseries

## ğŸ—ï¸ Overview

Suiviseries is a modern Angular 21 application built with current best practices and scalable modular architecture.

## ğŸ“± Technology Stack

### Frontend

- **Angular 21** - Main framework with standalone components
- **TypeScript 5.9** - Strict typing and modern features
- **Angular Material 21** - UI components with Material Design 3
- **RxJS 7** - Reactive programming and state management
- **Signals** - Angular's new reactivity API
- **Transloco** - Internationalization with MessageFormat

### Development Tools

- **Angular CLI 20** - Scaffolding and build system (with esbuild & webpack)
- **ESLint** - Linting with strict configuration
- **Prettier** - Consistent code formatting
- **Vitest + Jasmine** - Unit testing
- **Angular Builder** - Optimized build pipeline with tree-shaking

## ğŸ›ï¸ Component Architecture

### Hierarchical Structure

```
Application (app.component)
â”œâ”€â”€ Layout Components
â”‚   â”œâ”€â”€ Navigation (auto-generated by Angular Material)
â”‚   â””â”€â”€ Theme Provider (Angular Material 3)
â”œâ”€â”€ Feature Modules (Lazy Loaded)
â”‚   â”œâ”€â”€ Home Module
â”‚   â”‚   â””â”€â”€ PopularSeriesComponent
â”‚   â”œâ”€â”€ Search Module
â”‚   â”‚   â””â”€â”€ SeriesSearchComponent
â”‚   â”œâ”€â”€ Series Detail Module
â”‚   â”‚   â”œâ”€â”€ SerieDetailComponent
â”‚   â”‚   â”œâ”€â”€ SeasonListComponent (embedded)
â”‚   â”‚   â””â”€â”€ EpisodeListComponent (embedded)
â”‚   â”œâ”€â”€ My Series Module
â”‚   â”‚   â””â”€â”€ UserSeriesComponent
â”‚   â””â”€â”€ Auth Module
â”‚       â”œâ”€â”€ LoginComponent
â”‚       â””â”€â”€ AuthModalComponent
â””â”€â”€ Shared Components
    â”œâ”€â”€ SerieCardComponent (reusable)
    â”œâ”€â”€ SerieStatusChipComponent
    â””â”€â”€ LoadingSpinnerComponent
```

### Composition Pattern

#### Standalone Components

```typescript
@Component({
  selector: 'app-serie-card',
  standalone: true,
  imports: [CommonModule, RouterModule, MatCardModule, MatButtonModule],
  template: `...`,
})
export class SerieCardComponent {
  @Input() serie!: Serie;
  // Component logic
}
```

#### Modern Control Flow

```typescript
// Template with new control flow
@if (loading()) {
  <app-loading-spinner />
} @else {
  <div class="series-grid">
    @for (serie of series(); track serie.id) {
      <app-serie-card [serie]="serie" />
    }
  </div>
}
```

## ğŸ”„ State Management

### Reactive Architecture with Signals

#### Service Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class SeriesService {
  // Private state
  private seriesState = signal<Serie[]>([]);

  // Public state (read-only)
  readonly series = this.seriesState.asReadonly();

  // Actions
  loadSeries(): void {
    this.http.get<Serie[]>('/api/series').subscribe((series) => this.seriesState.set(series));
  }
}
```

#### Component Pattern

```typescript
export class SerieDetailComponent {
  // Signals for local state
  protected serie = signal<Serie | null>(null);
  protected loading = signal<boolean>(true);

  // Computed values
  protected isWatched = computed(() => {
    const currentSerie = this.serie();
    return currentSerie?.user_data?.is_watched || false;
  });
}
```

### Hierarchical Data Flow

#### Series â†’ Season â†’ Episode

```typescript
// Hierarchical synchronization logic
markSerieAsWatched() {
  // 1. Mark the series
  this.updateSerieStatus(true);

  // 2. Mark all seasons
  this.markAllSeasonsWatched();

  // 3. Mark all episodes
  this.markAllEpisodesWatched();
}

markSeasonAsWatched(seasonId: number) {
  // 1. Mark the season
  this.updateSeasonStatus(seasonId, true);

  // 2. Mark all episodes in the season
  this.markEpisodesInSeason(seasonId, true);

  // 3. Check if all seasons are marked
  this.checkAndUpdateSerieStatus();
}
```

## ğŸ›£ï¸ Routing System

### Route Configuration

```typescript
export const routes: Routes = [
  { path: '', loadComponent: () => import('./home/home.component') },
  { path: 'search', loadComponent: () => import('./search/search.component') },
  {
    path: 'my-series',
    loadComponent: () => import('./my-series/my-series.component'),
    canActivate: [authGuard], // Protection by guard
  },
  {
    path: 'serie/:id/:nom',
    loadComponent: () => import('./serie-detail/serie-detail.component'),
  },
];
```

### Authentication Guards

```typescript
export const authGuard: CanActivateFn = (route, state) => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isAuthenticated()) {
    return true;
  }

  // Redirect with returnUrl
  const returnUrl = state.url;
  router.navigate(['/'], {
    queryParams: { login: 'true', returnUrl },
  });
  return false;
};
```

## ğŸ”§ Services Architecture

### Dependency Injection

#### Modern Service Pattern

```typescript
@Injectable({ providedIn: 'root' })
export class SeriesService {
  private readonly http = inject(HttpClient);
  private readonly authService = inject(AuthService);

  // Using readonly for immutability
  private readonly apiUrl = environment.apiUrl;
}
```

#### Service Composition

```typescript
export class SerieDetailComponent {
  // Modern injection with inject()
  private readonly route = inject(ActivatedRoute);
  private readonly seriesService = inject(SeriesService);
  private readonly authService = inject(AuthService);

  ngOnInit() {
    // Reactive composition
    this.route.params
      .pipe(switchMap((params) => this.seriesService.getSerieDetails(params['id'])))
      .subscribe((serie) => this.serie.set(serie));
  }
}
```

## ğŸ“¡ Communication HTTP

### Interceptors & Error Handling

#### API Service Pattern

```typescript
@Injectable()
export class ApiService {
  private readonly http = inject(HttpClient);

  // Generic methods with error handling
  get<T>(endpoint: string): Observable<T> {
    return this.http.get<T>(`/api/${endpoint}`).pipe(catchError(this.handleError<T>()));
  }

  private handleError<T>(): (error: any) => Observable<T> {
    return (error: any): Observable<T> => {
      // Development-only logging
      if (!environment.production) {
        console.error('API Error:', error);
      }
      return of({} as T);
    };
  }
}
```

### Proxy Configuration

```json
// proxy.conf.json
{
  "/api/*": {
    "target": "http://localhost:8888/suiviseries-api/www",
    "secure": true,
    "changeOrigin": true,
    "logLevel": "debug"
  }
}
```

## ğŸ¨ Theming and Styles

### Angular Material 3 Configuration

#### Theme Setup

```scss
@use '@angular/material' as mat;

// M3 Theme Configuration
html {
  @include mat.theme(
    (
      color: (
        primary: mat.$rose-palette,
        tertiary: mat.$red-palette,
      ),
      typography: (
        brand-family: 'Roboto',
        bold-weight: 700,
      ),
    )
  );
}
```

## ğŸ§ª Testing Strategy

### Unit Testing Pattern

```typescript
describe('SerieDetailComponent', () => {
  let component: SerieDetailComponent;
  let mockSeriesService: jasmine.SpyObj<SeriesService>;

  beforeEach(() => {
    const spy = jasmine.createSpyObj('SeriesService', ['getSerieDetails']);

    TestBed.configureTestingModule({
      imports: [SerieDetailComponent], // Standalone component
      providers: [{ provide: SeriesService, useValue: spy }],
    });

    mockSeriesService = TestBed.inject(SeriesService) as jasmine.SpyObj<SeriesService>;
  });

  it('should load serie on init', () => {
    mockSeriesService.getSerieDetails.and.returnValue(of(mockSerie));

    component.ngOnInit();

    expect(component.serie()).toEqual(mockSerie);
  });
});
```

## ğŸš€ Performance Optimizations

### Bundle Optimization

- **Lazy Loading**: On-demand route loading
- **Tree Shaking**: Dead code elimination
- **Code Splitting**: Optimal chunk separation

### Runtime Performance

- **OnPush Strategy**: Optimized change detection
- **Signals**: Fine-grained reactivity
- **Computed Values**: Automatic memoization

## ğŸ“± Responsive Design

### Breakpoints Material Design

```scss
// Using Angular Material breakpoints
@use '@angular/cdk/layout';

.series-grid {
  display: grid;
  gap: 16px;

  // Mobile
  grid-template-columns: 1fr;

  // Tablet
  @media (min-width: 768px) {
    grid-template-columns: repeat(2, 1fr);
  }

  // Desktop
  @media (min-width: 1024px) {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

## ğŸ” Security Best Practices

### Authentication Flow

- **JWT Tokens**: Secure localStorage storage
- **Route Guards**: Protection of sensitive routes
- **CSRF Protection**: Security headers
- **Content Security Policy**: CSP configuration

### Data Sanitization

- **XSS Protection**: Angular's automatic sanitization
- **Input Validation**: Client-side and server-side validation
- **Type Safety**: Strict TypeScript to prevent runtime errors

---

This architecture ensures a **scalable**, **maintainable**, and **performant** application following modern Angular best practices.
